<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Derivative Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@12.2.0/lib/browser/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <h1>Derivative Calculator</h1>
    <input
      type="text"
      id="expression"
      placeholder="Enter function expression"
    />

    <button onclick="calculateDerivative()">Calculate Derivative</button>
    <div id="result"></div>
    <canvas id="myChart" width="400" height="200"></canvas>
    <script>
      function calculateDerivative() {
        // Retrieve expression from input
        const expressionInput = document.getElementById("expression");
        const expression = expressionInput.value;

        try {
          // Define variables for derivative function and default range
          let derivativeResult;

          // Convert expression to mathjs function with improved error handling
          let func;
          try {
            func = math.parse(expression, {
              scope: { x: true, y: 0, z: Math.PI },
            });
          } catch (error) {
            document.getElementById(
              "result"
            ).innerHTML = `Invalid expression: ${error.message}`;
            return;
          }

          // Initialize steps to accumulate calculation details
          let calculationSteps = [];

          // Calculate derivative
          derivativeResult = math.derivative(func, "x").toString();
          calculationSteps.push(`Derivative: ${derivativeResult}`);

          // Use Newton-Raphson method to find critical points with higher accuracy
          const criticalPoints = findCriticalPointsWithNewtonRaphson(
            derivativeResult,
            calculationSteps
          );

          // Calculate function values at critical points and endpoints
          const functionValues = criticalPoints.map((x) =>
            math.evaluate(func.toString(), { x })
          );

          // Find the highest and lowest values for extrema
          const maximum = Math.max(...functionValues);
          const minimum = Math.min(...functionValues);

          // Display derivative result, critical points, and extrema
          calculationSteps.push(
            `Critical points: ${JSON.stringify(criticalPoints)}`
          );
          calculationSteps.push(`Maximum value: ${maximum}`);
          calculationSteps.push(`Minimum value: ${minimum}`);

          // Display all calculation steps
          document.getElementById("result").innerHTML =
            calculationSteps.join("<br>");

          // Display chart
          displayChart(
            func,
            criticalPoints[0],
            criticalPoints[criticalPoints.length - 1]
          );
        } catch (error) {
          document.getElementById(
            "result"
          ).innerHTML = `An error occurred: ${error.message}`;
        }
      }

      function findCriticalPointsWithNewtonRaphson(derivative, steps) {
        const tolerance = 0.001; // adjust tolerance as needed
        const criticalPoints = [];

        // Iterate over a predefined range or use other logic to determine the range
        for (let x = -10; x <= 10; x += 0.1) {
          // Check if derivative is close to zero within tolerance
          const derivativeValue = math.evaluate(derivative, { x });
          if (Math.abs(derivativeValue) < tolerance) {
            criticalPoints.push(x);

            // Use Newton-Raphson method to refine the critical point
            let x0 = x;
            while (Math.abs(derivativeValue) > tolerance) {
              x0 =
                x0 -
                derivativeValue /
                  math.evaluate(math.derivative(derivative, "x"), { x: x0 });
              derivativeValue = math.evaluate(derivative, { x: x0 });
            }
            criticalPoints.push(x0);
            steps.push(`Critical point found at x = ${x0}`);
          }
        }

        return criticalPoints;
      }

      function displayChart(func, start, end) {
        const canvas = document.getElementById("myChart");
        const ctx = canvas.getContext("2d");

        const xValues = [];
        const yValues = [];

        for (let x = start; x <= end; x += 0.1) {
          xValues.push(x);
          yValues.push(math.evaluate(func.toString(), { x }));
        }

        const chartData = {
          labels: xValues,
          datasets: [
            {
              label: "Function Curve",
              borderColor: "rgba(75, 192, 192, 1)",
              borderWidth: 1,
              data: yValues,
            },
          ],
        };

        const chartOptions = {
          scales: {
            x: {
              type: "linear",
              position: "bottom",
            },
            y: {
              min: Math.min(...yValues),
              max: Math.max(...yValues),
            },
          },
        };

        new Chart(ctx, {
          type: "line",
          data: chartData,
          options: chartOptions,
        });
      }
    </script>
  </body>
</html>
